# 객체지향 패러다임; 협력, 책임, 역할

1. 객체도 사회적 동물이다
    - "공동체"를 만들ㅇ서 서로 상호작용 하여 자신의 존재여부를 증명한다
    - 객체간의 상호 작용은 "메세지"를 통해서만 가능하다

2. 객체지향 세계에서 객체는 자아를 가지는 로봇이 된다.
    - 객체로 구현되면 "능동적인" 존재가 된다

3. 객체지향 세계에서는 독점은 없다.
    - 객체지향 세계에서 모든 것을 가지고 있는 객체는 없다.
    - Application의 목표를 달성하기 위해서 필요한 기능을 쪼개서 적절한 객체에 분배하고 객체들 간의 적절한 협력을 만들어 주는 것이 목표다

협력이란? 
    - 주요 기능을 구현하기 위해서 작은 단위로 쪼개진 기능을 설명하는 한 줄 요약본
    - 협력은 객체 간의 상호작용을 통해서 이루어진다
    - 객체 간의 상호작용은 메시지를 통해서만 가능하다
    (ex. 주문 받기, 주문 결제 금액 계산, 커피 제조, 커피 전달)

책임이란?
    - 협력에 참여하기 위해서 객체가 맡고(=책임 지고) 있는 전체 기능 정의서
    (ex.
        1. 주문 받기
            a. 주문한 메뉴와 수량 계산
            b.
            c.
    ) 

역할이란?
    - 동일한 책임을 수행하는 객체의 집합체
    - 동일한 책임을 수행하는 객체가 여러 개 있을 경우, 협력을 개별적으로 만ㄷ르지 않는다. 동일한 책임을 수행하는 "객체들을 대표할 수 있는 특별한 이름(역할)"을 부여하고 그것들을 슬롯 형태로 관리하면 동적으로 적절한 객체로 결합한다.

    (ex. 통신사 할인금액 계산 -> "TelecomDiscountPolicy")

의존성: 객체의 영원한 친구
    - 의존성(Dependency)란?
        -> A 객체가 B 객체에게 "give me the money"라는 문맥을 가지는 메세지를 보냇을 때 B객체가 A객체가 보낸 메시지를 처리할 수 있다라는 사실을 "알고 있는 지식(정보)를 의존성"이라고 말한다
    - Coupling: 강한 결합도, 낮은 결합도
        -> B객체에 변경이 발생하는 경우, A 객체에 얼마만큼의 영향을 주느냐에 따라 낮은/높은 결합도(Coupling)이라고 한다.

    - 왜 Constructor를 통해서 의존성을 주입을 해야 하는가?
        -> 생각해보기
    
    - Parameter of Method를 통한 의존성 주입
        -> 언제?

    - Setter 함수를 통한 의존성 주입
        -> 언제?
            의존하고 있는 대상을 변경할 수 있는 가능성을 열어두고 있는 경우

    - 변경을 방해하는 의존성 관계
        "변경을 방해"한다라는 의미는 변경에 따른 영향이 전파 되는 범위가 너무 커서 변경을 할 수 없는 상황을 이야기 한다 -> Legacy
        - Constructor에서 new를 통한 객체 주입

    - 응집도와 결합도는 비례 or 반비례 관계일까?
        서로 영향을 주지 않는다
        "잘못된 캡슐화는 강한 결합도를 유발할수있다(X) 유발한다(O). 객체상태를 조작하는 책임은 객체 본인한테 있어야 하기 떄문이다 라고 이해했습니다!

상속; 재사용의 함정
    -상속이란?
        부모 클래스(Super or 기반 클래스)가 가지고 있는 상태와 행동을 자식 클래스(Sub or 기반 클래스)가 물려 받아 코드를 재사용 할 수 있게 해주는 방법

    - 왜 사용하는가?
        "코드의 중복"을 방지하기 위해서

    - 문제점:
        1. 
        2. 부모와 자식 사이의 강한 결합이 생김
            - 변경의 유연한 설계를 무력하게 하는 상속
    
    - 그래서 나쁜거냐?
        -No
            상속의 관계(ia -a) 관계가 명확하다면 사용해도 괜찮다


합성; 유연한 코드로 가는 길
    - 상속과 다른 점은?
        상속 관계는 컴파일 시점에 결정된다.
        합성 관계는 외부 객체를 런타임 시점에서 적절하게 선택하여 주입하는 구조
        -> 작은 기능들을 조합해서 다양한 기능을 만들어 낼 수 있는 구조 (OCP, DIP)


새로운 문법; 람다
    - 람다식:
        클래스 선언 없이 메서드를 정의할 수 있고, 이것을 값(Object) 처럼 사용 할 수 있는 "함수"
        람다식은 함수(Java 세상에서는 Method로 이해하면 좋다.)를 일급객체(First-class Object)로 취급하여 다른 함수의 인자(parameter)로 전달하거나, 함수에서 반환 값(return)으로 사용할 수 있다.

    - 일급 시민 객체; 함수도 값(value)으로 취급
        Method or Function를 사용할 때 다른 요소들과 아무런 차별이 없다는 것을 뜻함
    
    - 왜 사용하는가?
        1. 간결성
            - 복잡한 코드를 간결하게 표현함으로써 간결성과 가독성을 높일 수 있는 이점을 가지고 있다.
        2. 익명 클래스 대체
            - 비지니스 로직과 상관 없는 코드이면서 여러 곳에서 반복적으로 사용되는 코드(Boilerplage code)인 익명 클래스의 선언부를 제거 할 수 있다.
        3. 스트림 API
            - Java 8에서부터 도입된 API로 컬렉션 처리를 간결하게 처리할 수 있도록 다양한 기능을 제공한다.
            - 불변성 적용

    - 함수형 인터페이스; 람다를 제공하기 위한 문법
        - @FunctionalInterface 어디에서나 람다 표현식을 사용 할 수 있다.